import { MDXImage as Figure } from 'components/MDX';

## Issue #2: Code Quality and CI/CD

### Problem

Great, we solved the dependency management issue! But what about enforcing code quality in your
project? With statically typed language like Rust, or Java, the compiler catches a lot of issues for
you at the compilation time. Unfortunately, we don't have this luxury in our beloved dynamically
typed language.

Another important factor in a good codebase is **consistency**. Python does not come with a default
code formatter, but we need to somehow enforce good formatting practices and ideally, we want it to
be automatic.

### Solution

A good solution here covers 5 points.

#### 1. Static Type Checking

Python introduced type-annotation around 3.5. There are some great tools built around this type's
annotation feature. Remember that type-annotations are not enforced in Python, it's an optional
feature, you can run your code even if the annotations are wrong or not respected. To do the actual
type checking and verify that our code is correct at compilation time we will use **Mypy**. It's a
static type checker built for python. If you come from statically typed languages, compiler checks
miss you to catch a lot of potential bugs. Mypy will force you to spend a bit of time writing and
conforming to type-annotations, but this investment will pay sooner than you can think.

#### 2. Formatting

To format python code, my favorite tools are **Black** and **Isort**. They come with a predefined
set of rules which are a great default and you can easily customize them in the `pyproject.toml`
configuration. Black will help you format your code, i.e., breaking too-long lines, enforcing
newlines between functions, and so on. Isort will help you keep your imports sorted with separation
between python built-ins, first-party and third-party dependencies. It's better to keep it
consistent across all files in your project.

<Figure
  ratio={16 / 9}
  width="100%"
  maxWidth="500px"
  src="https://statics.bitswired.com/images-opti/blog/python-formatting-before-after.webp"
  alt="before and after code formatting"
  title="Before/after code formatting"
  objectFit="contain !important"
/>

#### 3. Linting

Linting is another code quality tool. It checks your code against a huge list of rules and will tell
you which one you break. Rules like no unused variables, duplicated names, wrong inheritance, ... It
is important for your project's health. There is a lot of linters available like Pylint, Flake8,
Autopep ... I personally use **Flake8**.

#### 4. Testing

Python has native support for unit tests. However, IÂ  encourage you to use Pylint which is a
powerful tool to write test with features that makes your life easier, especially the powerful
fixture. I might come back to Pytest in another article.

#### 5. CI/CD

Most likely, you are using a tool like GitHub to save your git repository remotely. Ideally, you
want to run all your code quality checks before any code is merged to your master branch to avoid
codebase deterioration over time. We have 2 complementary ways to do it:

1. Pre-commit hooks: these are scripts run before each commit locally, they will run all your code
   quality tools and deny the commit if the code doesn't pass. This is an easy way to enforce best
   practices at every commi width: string;
2. GitHub actions: these are scripts run automatically by GitHub on certain triggers. For instance,
   when you **open a pull request**, GitHub will build your code in a container and run all your
   code checks. It will prevent you to merge the pull request into master if the checks did not pass

Using a combination of both is the recommended way. Indeed pre-commit hooks are fast since they run
locally, you don't need to wait for GitHub remotely. However, nothing guarantees you that every
developer runs the pre-commit hooks before pushing code. So having the GitHub actions checking your
code is the ultimate guarantee that all code merged on master lives up to your quality standards.

In the solution proposed here, I use a Python library `pre-commit` to automatically run all the
checking tools before each commit. Finally, I set up a GitHub action to run pre-commit before
merging a pull request into master to ultimately enforce the code qualtiy.
