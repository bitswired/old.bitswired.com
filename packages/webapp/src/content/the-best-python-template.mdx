---
title: The Best Python Project Template
description:
readMinutes: 20
image: https://statics.bitswired.com/images-opti/blog/code.webp
tags: [Python, Template, Best-Pracices]
slug: the-best-python-template
published: true
---

## TLDR

_Python is a great language with a lot of libraries available. You have everything. From gaming to
artificial intelligence, even backend or automation. There is one main catch, the lack of structure
and easy mess due to the dynamic types. In this article, I identify all these problems and give you
a solution for each. Finally, I share with you a Github template repository to **start your new
Python projects on the right foot, and ship high-quality code in no time**!_

Check the repository at:
[https://github.com/bitswired/perfect-python-starter](https://github.com/bitswired/perfect-python-starter).<br/>
Let a star if it helps you!

## Introduction

As a machine learning engineer, Python is one of my daily tools. It's an expressive language, fast
to write and it has one of the richest ecosystems. Not to mention that most of the tools to build
artificial intelligence are available in Python. However, I would identify 2 main drawbacks which
can undermine your productivity and code robustness: the **lack of structure** (dynamic types) and
the **lack of built-in code quality tools**.

## Issues #1: Dependency Management

{/* <Figure
  ratio={16 / 9}
  width="100%"
  src="https://wallpapercave.com/wp/wp4676582.jpg"
  alt="image"
  title="Title"
/> */}

### Problem

Installing third-party libraries is an essential step in any programming project. But it's not
enough. It should be possible to version control the library you use and install the project with
all its dependencies on any computer. Also, you want isolation. Indeed if you have multiple projects
depending on the same library but with a different version, you don't want them to conflict with
each other.

The standard way to tackle these problems in Python are pip (to install packages) and virtual
environments (for isolation). The typical workflow is:

1. You create a folder for your project
2. Create a virtual environment
3. Install dependencies with pip
4. Store the dependencies list in a file, requirements.txt using pip freeze

This provides you:

- **Isolation**: packages installed in the virtual environment are isolated from the rest of the
  system
- **Reproducibility (somehow)**: you can reinstall all the dependencies when you download the
  project, but you are not guaranteed to reach the same style at another point in time.

But, there are some problems:

- **Dependency mix**: you get a `requirements.txt` file mixed with your dependencies and the
  dependencies of your dependencies. It's a mess to track easily the packages you really depend on
- **Week reproducibility**: you are not guaranteed to reach the same project dependencies state if
  you reinstall your project later. pip freeze does not lock dependencies

### Solution

Use another package manager: [Poetry](https://github.com/python-poetry/poetry). It's a modern
package manager and builder. It's really simple from a utilization point. All you need to provide is
one file: the pyproject.toml file. It solves the 2 problems mentioned above.

- **Clean dependencies**: in your `pyproject.toml` file you only specify the direct dependency for
  your project. It will never get mixed with dependency from other packages
- **Strong reproducibility**: poetry introduces a lock file to your project, in this file all
  dependencies are locked to the version resolved at the installation. You are guaranteed to have
  the same dependency state for your project whenever you're installing it

## Issue #2: Code Quality and CI/CD

### Problem

Great, we solved the dependency management issue! But what about enforcing code quality in your
project? With statically typed language like Rust, or Java, the compiler catches a lot of issues for
you at the compilation time. Unfortunately, we don't have this luxury in our beloved dynamically
typed language.

Another important factor in a good codebase is consistency. Python does not come with a default code
formatter, but we need to somehow enforce good formatting practices and ideally, we want it to be
automatic.

### Solution

#### Static Type Checking

Python introduced type annotation around 3.5. There are some great tools built around this
type's annotation feature. Remember that type-annotations are not enforced in Python, it's an
optional feature, you can run your code even if the annotations are wrong or not respected. To do
the actual type checking and verify that our code is correct at compilation time we will use Mypy.
It's a static type checker built for python. Believe me, if you come from statically typed
languages, compiler checks miss you to catch a lot of potential bugs. Mypy will force you to spend a
bit of time writing and conforming to type-annotations, but this investment will pay sooner than you
can think.

#### Formatting

To format python code, my favorite tools are Black and Isort. They come with a predefined set of
rules which are a great default. And you can easily customize them in the pyproject.toml
configuration. Black will help you format your code automatically, breaking too-long lines,
enforcing newlines between functions... Isort will help you keep your imports sorted. It's important
to keep it consistent for your project.

#### Linting

Linting is another code quality tool. It checks your code against a huge list of rules and will tell
you which one you break. Rules like no unused variables, duplicated names, wrong inheritance, ...
It is important for your project's health. There is a lot of linters available like pylint, Flake8,
autopep ... I personally use flake8.

#### Testing

Python has native support for unit tests. However, I  encourage you to use Pylint which is a powerful
tool to write test with features that makes your life easier, especially the powerful fixture. I
might come back to Pytest in another article.

#### CI/CD

Bla bla

## Issue #3: Packaging

### Problem

Awesome, you have a project ready to be packaged and published to pipy! But wait, you first need to
get it publish-ready and go through a list of steps that can be cumbersome
[see here](https://packaging.python.org/tutorials/packaging-projects/).

### Solution

Again poetry helps us there. It's super simple to build your package and publish it. You mainly have
2 commands to use: poetry build and poetry publish. Never be afraid to publish your package.

## Bonus: VScode Integration

If you're, like me, using VScode, there is an awesome Python language server called Pylance. I
encourage you to enable this feature for all your project. You can control the level of severity for
the type checking, so you can adopt it progressively. It will catch tons of potential errors in your
code just by checking the types.

## The Best Python Template To Start

Implementing all these good practices can feel too demanding especially if you are a beginner.
However, I definitely encourage you to apply these good practices as early as possible in your
coding habits. It will overall make you a better coder, producing better quality code, and avoiding
easy-to-catch pitfalls and bugs. Even for an advanced programmer, it can be cumbersome to do it again and
again for every project. All we want to do is code our project right?

I've made a **GitHub template repository** addressing all the issues. It's really easy to use, when
you create a new Python project, start it from my GitHub template. You will only have to run
poetry install to get all the dev dependencies required for the tooling: **linting**, **formating**,
**type checking**. You will also have **poetry** to handle your dependencies and be ready to ship
high-quality code in no time! Check it out.

## Conclusion
